# 关卡描述

## 第一关

### 任务描述

* 完成图的邻接矩阵数据结构定义，及图初始化函数。

### 相关知识

#### 有向图和无向图

* 对无向图来说，邻接矩阵是对称矩阵，存储时需NN的矩阵，N为顶点数。
* 如下图所示

    ![image](https://www.educoder.net/api/attachments/1131842)

* 则存储该无向图需44的二维数组，对无权图来说，元素为0或1，若顶点之间有边，则为1，否则为0。上图所示图对应的邻接矩阵如下：

    ``` cpp
        0 1 0 0
        1 0 1 1
        0 1 0 1
        0 1 1 0
    ```

#### 如何输入图

* 输入图需输入两个关键信息：
  1. 图的顶点
  2. 图的边或弧
* 输入边或弧的时候，可通过输入边或弧的两个邻接点实现。

### 测试样例

* 为使算法通用于无向图和有向图，在图数据结构中设置一个标志，用于标志图是有向图还是无向图。

* 输入输出说明：
  * 第一行输入图的类型、图的顶点数和边数。图的类型包括：1（有向图）, 0（无向图）。
  * 第二行输入各条边的两顶点的编号，按顶点编号从小到大的顺序输入。输出邻接矩阵。

* 如创建下图

![image](https://www.educoder.net/api/attachments/1131851)

* 测试输入：

    ``` cpp
        0 5 6 //图的类型为0表示无向图，图的顶点数为5，图的边数为6
        0 1 0 3 1 2 1 4 2 3 2 4 //输入各条边的两顶点的编号，按顶点编号从小到大的顺序输入
    ```

* 预期输出：

    ``` cpp
    0 1 0 1 0
    1 0 1 0 1
    0 1 0 1 1
    1 0 1 0 0
    0 1 1 0 0
    ```

## 第二关

### 任务描述

* 编写一个能输入图的基本信息（含图的类型，图的顶点，边等），并用邻接表存储图的程序。

### 相关知识

* 图的邻接表分两部分：

  1. 顶点表，是一个顺序表，用于存储顶点的值，及与该顶点相邻的第一个顶点指针；
  2. 边表：是一个链表，每个结点存储与相应顶点有边的另一个顶点编号及下一个顶点指针。

* 举例，如下所示：
    ![images](https://www.educoder.net/api/attachments/1131951)
* 其邻接表：
    ![images](https://www.educoder.net/api/attachments/1131952)

### 测试说明

* 在插入边表时，为尽可能提高效率，直接在边表表头进行插入。
* 测试输入: ``0 4 5 0123 0 1 0 2 0 3 1 2 1 3``
* 预期输出:

    ``` cpp
    0->3->2->1
    1->3->2->0
    2->1->0
    3->1->0
    ```

## 第三关

### 任务描述

* 实现图的广度遍历。

### 相关知识

#### 图的广度遍历算法描述

* 从指定顶点`v`出发，先访问顶点`v`, 并将其标记为已访问
* 依次访问`v`的所有相邻结点``w1, w2, …, wx``, 然后依次访问与``w1, w2, …, wx``邻接的所有未访问顶点；依次类推，直到所有已访问顶点的相邻结点都已访问为止
* 如果图中还有未访问顶点，则选择一个未访问顶点，由它出发进行广度优先搜索，直到所有顶点都已访问为止
* 如下图，从`V0`开始，根据存储结构可能产生不同的广度遍历结果

    ![img](https://www.educoder.net/api/attachments/1132266)

* 则从V0开始的广度优先遍历结果：`0 3 1 2 4`
若采用邻接矩阵存储，则输出的广度优先周游结果：`0 1 3 2 4`

### 测试说明

* 使用图的邻接表存储结构，并基于该存储结构实现图的广度遍历。
* 第一行输入图的类型、图的顶点数和边数。
* 第二行输入各条边的两顶点的编号，按顶点编号从小到大的顺序输入。
* 输出广度优先遍历的结果。
* 测试输入：`0 6 7 012345 0 1 0 2 0 3 1 5 2 4 3 4 4 5`
* 预期输出：`0 3 2 1 4 5`

## 第四关

### 任务描述

* 实现图的深度遍历

### 相关知识

#### 图的深度遍历算法

* 从指定顶点`v`出发, 先访问`v`并将其标记为已访问
* 访问顶点`v`的未被访问过的某一个邻接顶点`w`
* 访问顶点`w`的未被访问过的某一个邻接顶点`x`
* 重复第2、3步，直至图中与`v`连通的所有顶点都被访问。如果图中还有未访问的顶点，则选一个未访问顶点，由它出发重复上述过程，直到图中所有顶点都被访问为止

* 如下图，从V0开始，根据存储结构可能产生不同的深度遍历结果
    ![img](https://www.educoder.net/api/attachments/1132266)
* 则从V0开始的广度优先遍历结果： `0 3 1 4 2`
* 若采用邻接矩阵存储，则输出的广度优先周游结果：`0 1 2 3 4`
  
### 测试说明

* 第一行输入图的类型、图的顶点数和边数。
* 第二行输入各条边的两顶点的编号，按顶点编号从小到大的顺序输入。
* 输出深度优先遍历的结果。
* 测试输入：`0 5 6 01234 0 1 0 3 1 2 1 4 2 3 2 4`
* 预期输出：`0 3 2 4 1`

## 第五关

### 关卡描述

* 编写一个能输出有向无环图的拓扑排序的函数。

### 相关知识

#### 拓扑排序

* 对一个有向无环图(Directed Acyclic Graph简称DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边<u,v>∈E(G)，则u在线性序列中出现在v之前。通常，这样的线性序列称为满足拓扑次序(Topological Order)的序列，简称拓扑序列。简单的说，由某个集合上的一个偏序得到该集合上的一个全序，这个操作称之为拓扑排序
* 如下图表示的是一个课程先后修的关系图：
    ![img](https://www.educoder.net/api/attachments/1133874)
* 找到一个合理的课程先后选修序列就可以抽象为对该图进行一个拓扑排序过程。
* 在AOV网种拓扑排序不一定存在。
* 在有向无环图中必然存在拓扑排序，但排序不一定唯一。

#### 拓扑排序策略

* 本关仅考虑有向无环图的拓扑排序
    1.从图中选择一个入度为0的顶点将其输出
    2.在图中删除此顶点及其所有的出边
* 反复执行以上两步，直到所有顶点都已经输出为止，此时整个拓扑排序完成。
* 在创建图的邻接矩阵时要对顶点的入度进行维护。

### 测试样例

* 测试输入: `1 6 7 012345 0 2 1 2 1 3 1 4 2 3 3 5 4 5`
* 预期输出: `0 1 2 3 4 5`

## 第六关

### 任务描述

* 实现prim算法生成最小生成树。

### 相关知识

#### 生成树

* 对于连通的无向图或强连通的有向图，从任一顶点出发周游，可以访问到图中所有的顶点。周游时经过的边加上所有顶点构成了图的一个连通子图（不存在回路），称为图的一棵生成树。
* 图的生成树不唯一，假设网络的生成树中的边也带权，将生成树各边的权值加起来称为生成树的权，权值最小的生成树称为最小生成树（Minimum Spanning Tree，简称为MST）。

#### prim算法简述

* 设G=(V，E)是具有n个顶点的网络，T=(U，TE)为（构造中的）G的最小生成树，U是T的顶点集合，TE是T的边集合，T初始状态是空树。
* 从集合V中任取一顶点（例如顶点v0）放入集合U中，则U={v0}，TE=NULL
* 检查所有一个顶点在集合U中，另一个顶点在集合V-U中的边，找出权最小的边(u,v) (u∈U，v∈V-U)，将该边放入TE，并将顶点v加入集合U
* 重复上述操作直到U=V为止，此时TE中有n-1条边，T=(U,TE)即G的一棵最小生成树。

### 测试说明

* 如图所示
    ![img](https://www.educoder.net/api/attachments/1136944)
* 测试输入：`0 6 10 012345 0 1 10 1 2 5 2 3 9 1 3 7 1 5 11 3 5 14 0 5 21 0 4 19 3 4 18 4 5 33`
* 预期输出：按选择边的顺序输出边的两个顶点（从顶点0开始，顶点编号小的在前）

    ``` cpp
    0 1
    1 2
    1 3
    1 5
    3 4
    ```
